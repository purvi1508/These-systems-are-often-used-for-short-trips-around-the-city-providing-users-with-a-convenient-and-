# -*- coding: utf-8 -*-
"""test1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NTTh_vcLV-jTp1uu2wtOOSllC4l6OIJ4
"""


import sklearn
import time
import pandas as pd
import numpy as np

df = pd.read_csv('/content/bike_data_new.csv')

from datetime import datetime, timedelta

def remove_zero_duration_trips(df):
    num_rows, num_cols = df.shape

    countinitial=len(df)

    print(f"Initial DataFrame shape: {num_rows} rows, {num_cols} columns")
    df['started_at'] = pd.to_datetime(df['started_at'], format='%d-%m-%Y %H:%M')
    df['ended_at'] = pd.to_datetime(df['ended_at'], format='%d-%m-%Y %H:%M')

    df['time_diff'] = df['ended_at'] - df['started_at']
    df.drop(df[df['time_diff'] == timedelta(seconds=0)].index, inplace=True)
    
    num_rows, num_cols = df.shape
    print(f"New DataFrame shape: {num_rows} rows, {num_cols} columns")
    
    Minimum_duration = df['time_diff'].min()

    Maximum_duration = df['time_diff'].max()

    num_trips_minimum = len(df[df['time_diff'] ==  Minimum_duration])
    print(f"Total number of trips corresponding to the minimum duration of {Minimum_duration} minutes: {num_trips_minimum}")

    df['Num_Circular_Trips'] = ((df['start_lat'] == df['end_lat']) & (df['start_lng'] == df['end_lng']))
    countafter = df[df["Num_Circular_Trips"] == True].shape[0]

    print(f"New minimum trip duration: {int(Minimum_duration.total_seconds() // 60)} minutes")
    print(f"New maximum trip duration: {int(Maximum_duration.total_seconds() // 60)} minutes")
    print(f"total circular trips percetage: {(countafter/countinitial)*100}")
   
    return df



start_time = time.time()
df = remove_zero_duration_trips(df)
end_time = time.time()

total_time = end_time - start_time
print(f"Total runtime: {total_time:.2f} seconds")

df['started_at'] = pd.to_datetime(df['started_at'], format='%d-%m-%Y %H:%M')
df_filtered = df[(df['started_at'].dt.hour >6) & (df['started_at'].dt.hour < 18)]

length_trip=len(df_filtered)

print(f"Total number of filtered trips: {length_trip} ")



df_duplicate = df_filtered.copy()
df_filtered = df_filtered.reset_index(drop=True)
df_duplicate = df_duplicate.reset_index(drop=True)
start_time = time.time()

# Checking if duplicated[ended_at] >= df_filtered[started_at]
mask = df_duplicate['started_at'].values[:, np.newaxis] >= df_filtered['ended_at'].values

# Checking end location comparison time of the trip B is greater than or equal to the end time of the trip A.
mask &= (df_duplicate['start_lat'].values[:, np.newaxis] == df_filtered['end_lat'].values) & (df_duplicate['start_lng'].values[:, np.newaxis] == df_filtered['end_lng'].values)

# Exclude pairs with the same trip ID
mask &= (df_filtered['trip_id'].values != df_duplicate['trip_id'].values[:, np.newaxis])

matching_indices = np.argwhere(mask)

matching_pairs = pd.DataFrame({'filtered_trip_id': df_filtered.loc[matching_indices[:, 0], 'trip_id'].values,'duplicate_trip_id': df_duplicate.loc[matching_indices[:, 1], 'trip_id'].values
})

matching_pairs = matching_pairs.drop_duplicates()

end_time = time.time()

total_time = end_time - start_time
print(f"Total runtime: {total_time:.2f} seconds")

len(matching_pairs)

df_new=df.head(100)

depots_df = df_new[['start_lat', 'start_lng', 'end_lat', 'end_lng']]

depots_df.drop_duplicates(subset=['start_lat', 'start_lng', 'end_lat', 'end_lng'], inplace=True)

len(depots_df)

depots_df

start_time = time.time()
max_value = 0
min_value = float('inf')
for i in range(len(depots_df) - 1):
  
  G = ox.graph_from_point((depots_df['start_lat'].iloc[i], depots_df['start_lng'].iloc[i]),network_type='drive')

  for index, row in depots_df.iloc[i+1:].iterrows():
    start = (row['start_lat'], row['start_lng'])
    end = (row['end_lat'], row['end_lng'])

    try:
        start_node = ox.distance.nearest_nodes(G, start[1], start[0])
        end_node = ox.distance.nearest_nodes(G, end[1], end[0])
        try:

            shortest_path_length = nx.dijkstra_path_length(G, start_node, end_node, weight='length')
            if shortest_path_length>0:
                max_value= max(max_value, shortest_path_length)
                min_value= min(min_value, shortest_path_length)
        except nx.NetworkXNoPath:

            print(f"No path found between the start and end nodes in row {index}.")
            shortest_path_length = -1


        print(f"Shortest path length between the start and end points in row {index} is {shortest_path_length} meters")

    except nx.NodeNotFound:
        print(f"The start and end nodes in row {index} are not reachable from each other.")
        shortest_path_length = -1

print(f"Maximum shortest path length: {max_value} meters")

print(f"Minimum shortest path length: {min_value} meters")

total_time = end_time - start_time
print(f"Total runtime: {total_time:.2f} seconds")

import osmnx as ox
import networkx as nx
count=0
# define the city of interest
city = 'Washington, DC, USA'
start_time = time.time()
# download the road network for the city
G = ox.graph_from_place(city, network_type='drive')
max_value = 0
min_value = float('inf')
# iterate over each row in the DataFrame
for index, row in depots_df.iterrows():

    start = (row['start_lat'], row['start_lng'])
    end = (row['end_lat'], row['end_lng'])

    try:
        # find the nearest nodes in the network to the start and end points
        start_node = ox.distance.nearest_nodes(G, start[1], start[0])
        end_node = ox.distance.nearest_nodes(G, end[1], end[0])

        # calculated the shortest path length between the start and end nodes using Dijkstra's algorithm
        try:
            shortest_path_length = nx.dijkstra_path_length(G, start_node, end_node, weight='length')
            if shortest_path_length>0:
              max_value= shortest_path_length
            if shortest_path_length<min_value  and shortest_path_length>0:
              min_value= shortest_path_length
        except nx.NetworkXNoPath:
            print(f"No path found between the start and end nodes in row {index}.")
            shortest_path_length = -1

        print(f"Shortest path length between the start and end points in row {index} is {shortest_path_length} meters")

    except nx.NodeNotFound:
        print(f"The start and end nodes in row {index} are not reachable from each other.")
        shortest_path_length = -1

end_time = time.time()

total_time = end_time - start_time
print(f"Total runtime: {total_time:.2f} seconds")

print(max_value)

print(min_value)

